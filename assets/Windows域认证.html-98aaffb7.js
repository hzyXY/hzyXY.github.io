import{_ as e,W as i,X as r,a1 as s}from"./framework-b6a07282.js";const l="/assets/1-9cac0321.jpg",a="/assets/2-4c4d0471.jpg",S="/assets/3-1cadaa36.jpg",o="/assets/4-4c7b186c.jpg",t={},T=s('<h2 id="windows域认证" tabindex="-1"><a class="header-anchor" href="#windows域认证" aria-hidden="true">#</a> Windows域认证</h2><h3 id="kerberos协议" tabindex="-1"><a class="header-anchor" href="#kerberos协议" aria-hidden="true">#</a> Kerberos协议</h3><ul><li>Kerberos是一种计算机网络身份认证协议，它基于票据（tickets）的机制。让在非安全网络上通信的节点能够以安全的方式证明彼此的身份。它主要针对客户端-服务器模型设计，提供了双向认证——用户和服务器都验证对方的身份。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</li></ul><h4 id="kerberos协议的角色" tabindex="-1"><a class="header-anchor" href="#kerberos协议的角色" aria-hidden="true">#</a> Kerberos协议的角色</h4><ul><li>客户端（client）：发送请求的一方</li><li>服务器端（Server）：接收请求的一方</li><li>密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是： AS（Authentication Server）：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据） TGS（Ticket Granting Ticket）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）</li></ul><h4 id="kerberos认证流程" tabindex="-1"><a class="header-anchor" href="#kerberos认证流程" aria-hidden="true">#</a> Kerberos认证流程</h4><ul><li>简单来说：客户端在访问每个想要访问的网络服务时，他需要携带一个专门用于访问该服务并且能够证明自己身份的票据，当服务端收到了该票据他才能认定客户端身份正确，向客户端提供服务。</li><li>1、客户端向KDC请求获取想要访问的目标服务的服务授予票据（Ticket）。</li><li>2、客户端拿着从KDC获取的服务授予票据（Ticket）访问相应的网络服务。</li></ul><h5 id="第一步-客户端和as进行通信" tabindex="-1"><a class="header-anchor" href="#第一步-客户端和as进行通信" aria-hidden="true">#</a> 第一步，客户端和AS进行通信</h5><ul><li>为了获得能够用来访问服务端服务的票据，客户端首先需要来到KDC获得服务授予票据（Ticket）。由于客户端是第一次访问KDC，此时KDC也不确定该客户端的身份，所以第一次通信的目的为KDC认证客户端身份，确认客户端 是一个可靠且拥有访问KDC权限的客户端。</li></ul><img src="'+l+'"><ol><li><p>客户端用户向KDC以明文的方式发起请求，请求中携带了自己的用户名、主机IP、和当前时间戳。</p></li><li><p>KDC中的AS接收到请求后，会去Kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会验证身份。</p></li><li><p>如果没有在数据中找到用户名，则认证失败。如果存在该用户名，则AS会返回响应给客户端，其中包含两部分内容：</p><p>(1).使用TGS密码加密的TGT（票据授予票据），客户端需要使用TGT去访问KDC中的的TGS（票据授予中心）获取网络服务所需的Ticket（服务授予票据）。TGT中包含有Kerberos数据库中存在的该客户端的Name、IP、当前时间戳、客户端即将访问的TGS的NAME、TGT票据有效时间、Session_key(CT_SK，用于和TGS进行通信)。整个TGT使用TGS的密钥进行加密</p><p>(2).使用客户端密码加密的一段内容，包含Session_key(CT_SK，用于和TGS进行通信)、即将访问的TGS的NAME、TGT票据有效时间、当前时间戳。客户端可以通过自己的密钥进行解密，如果是一个伪造的客户端，他是不会拥有真正客户端的密钥的。这同时也认证了客户端的身份。</p></li></ol><h5 id="第二步-客户端和tgs进行通信" tabindex="-1"><a class="header-anchor" href="#第二步-客户端和tgs进行通信" aria-hidden="true">#</a> 第二步，客户端和TGS进行通信</h5><ul><li>此时客户端已经接收到来KDC中AS的响应，并获取到了其中的两部分内容。客户端会用自己的密钥将第二部分内容进行解密，获取到Session_key(CT_SK，用于和TGS进行通信)、即将访问的TGS的NAME、TGT票据有效时间、当前时间戳。首先他会根据时间戳判断该时间戳与自己发送请求的时间之间的差是否大于5分钟，如果大于5分钟则认证失败。如果小于5分钟，则向TGS发起请求。</li></ul><img src="'+a+'"><p>客户端：</p><ol><li>客户端将自己的信息发送给KDC，包含用户名、主机IP、和当前时间戳。使用CT_SK进行加密。</li><li>客户端会把自己想要访问的Server服务以明文的方式发送给KDC。</li><li>客户端将AS发送过来的TGT原封不动地发送给KDC（TGS）</li></ol><p>TGS：</p><ol><li>当KDC中地TGS（票据授予服务器）收到了来自客户端的请求后，首先会根据传输过来的Server服务器IP来查看Kerberos系统中是否存在对应的服务，且允许用户访问。如果不存在，则认证失败。</li><li>TGS使用自己的密钥将TGT中的内容进行解密，此时他看到经过AS认证后并记录的用户信息、CT_SK、时间戳信息。他会根据时间戳来判断是否超时。</li><li>如果没有超时，则会使用CT_SK对客户端自身发送过来的内容进行解密，取出的用户信息和TGT中的用户信息进行对比，如果全部相同则认为客户端身份正确。</li><li>此时TGS会将响应发送给客户端，相应内容包括： (1)：使用Server密码加密的ST（Server Ticket，用于访问网络服务）：包含客户端的用户名、IP地址、目标服务器的Server IP、ST有效时间、时间戳、CS_SK（Session Key 用于客户端和服务器之间通信） (2)：使用CT_SK加密的内容：包含时间戳、CS_SK、ST有效时间。由于在第一次通信的过程中，AS把CT_SK发送给了客户端，客户端时可以自己解密该内容的。</li></ol><h5 id="第三步-客户端和服务器进行通信" tabindex="-1"><a class="header-anchor" href="#第三步-客户端和服务器进行通信" aria-hidden="true">#</a> 第三步，客户端和服务器进行通信</h5><ul><li>此时客户端收到了来自TGS的响应，并使用本地缓存的CT_SK解密出了第二段内容，第一段内容ST是由Server密码加密的，客户端无法解密。检查时间戳没有超时后去除其中的CS_SK准备向服务器端发起最后的请求。</li></ul><img src="'+S+'"><p>客户端：</p><ol><li>客户端使用CS_SK将自己的用户名、主机IP、时间戳、ST有效时间加密，并且和ST一起发送给服务器</li></ol><p>服务器：</p><ol><li>服务器收到来自客户端的请求后，会使用自己的密钥，将客户端的第一部分内容进行解密，核对时间戳没有超时后，取出CS_SK，使用CS_SK将客户端的第二部分内容进行解密，从而获取经过TGS认证过后的客户端信息。服务器会将两份内容和自己的信息进行对比，如果无误则确认该客户端通过了KDC认证，此时服务器返回一段使用CS_SK加密的数据表示接收请求的响应给客户端，客户端收到请求后使用缓存在本地的CS_SK解密，从而确定了服务器的身份。</li></ol><p>至此Kerberos认证完成。</p><img src="'+o+'">',27),c=[T];function n(d,h){return i(),r("div",null,c)}const K=e(t,[["render",n],["__file","Windows域认证.html.vue"]]);export{K as default};
