import{_ as i,W as a,X as l,a1 as e}from"./framework-b6a07282.js";const h="/assets/1-2d7d21dd.jpg",r="/assets/2-a2e81e4c.jpg",d="/assets/3-98a922ad.jpg",n={},s=e(`<h2 id="逻辑漏洞" tabindex="-1"><a class="header-anchor" href="#逻辑漏洞" aria-hidden="true">#</a> 逻辑漏洞</h2><ul><li>逻辑漏洞就是基于开发人员设计程序的时候，逻辑不严密，导致攻击者可以修改、绕过或者中断整个程序，让程序按照开发人员的预料之外去执行。简单来说，只要你能修改、绕过、中断整个开发者运行软件的整体逻辑，这个便是逻辑漏洞。</li></ul><h3 id="逻辑漏洞的分类" tabindex="-1"><a class="header-anchor" href="#逻辑漏洞的分类" aria-hidden="true">#</a> 逻辑漏洞的分类</h3><h4 id="软件设计之初便存在的漏洞" tabindex="-1"><a class="header-anchor" href="#软件设计之初便存在的漏洞" aria-hidden="true">#</a> 软件设计之初便存在的漏洞</h4><ul><li>关键在于开发设计者，如永恒之蓝、sql注入、文件上传等，都是设计的时候未按照安全设计的方法进行设计所产生的，攻击者只需找到特定的点，执行特定的代码即可产生研发预料之外的现象。</li></ul><h4 id="使用者未能安全使用软件所产生" tabindex="-1"><a class="header-anchor" href="#使用者未能安全使用软件所产生" aria-hidden="true">#</a> 使用者未能安全使用软件所产生</h4><ul><li>关键在于使用者，如弱口令、匿名用户等。程序开发者会设计很多便携的功能，但是由于使用者的使用不当，产生了问题。</li></ul><h3 id="身份验证漏洞" tabindex="-1"><a class="header-anchor" href="#身份验证漏洞" aria-hidden="true">#</a> 身份验证漏洞</h3><h3 id="暴力破解" tabindex="-1"><a class="header-anchor" href="#暴力破解" aria-hidden="true">#</a> 暴力破解</h3><h4 id="未限制爆破" tabindex="-1"><a class="header-anchor" href="#未限制爆破" aria-hidden="true">#</a> 未限制爆破</h4><ul><li>未限制爆破，即对于用户登陆的地方没有做任何限制策略</li></ul><p>利用方式：直接抓包进行爆破。</p><h4 id="限制ip爆破" tabindex="-1"><a class="header-anchor" href="#限制ip爆破" aria-hidden="true">#</a> 限制IP爆破</h4><ul><li>当短时间内有大量来自同一ip的尝试登录现象就会封锁该IP，导致该IP无法继续进行登录。</li></ul><p>解决思路：</p><pre><code>1. 变换不同的ip进行爆破
1. 写脚本设置不同的ip进行爆破
1. 调用git开源的代理API进行爆破
</code></pre><h4 id="限制密码错误次数来爆破" tabindex="-1"><a class="header-anchor" href="#限制密码错误次数来爆破" aria-hidden="true">#</a> 限制密码错误次数来爆破</h4><ul><li>限制了账号的登录次数，如果超过限制次数则账号锁定。除非管理员解锁或等待一段时间后自动解锁。</li></ul><p>发散性思维利用：如果某网站限制了密码错误次数，但不限制你换个账号再来继续尝试登录。每次的登录都是有相关信息回显，如：密码错误，该账号不存在。则可以用来爆破账号，通过账号字典来猜解该网站的所有账号。</p><h4 id="多字段爆破" tabindex="-1"><a class="header-anchor" href="#多字段爆破" aria-hidden="true">#</a> 多字段爆破</h4><ul><li>多字段爆破即为需要爆破的字段大于或等于2，如需要爆破账号密码和验证码。</li></ul><p>工具利用：可使用burp suite的intruder模块，根据情况（如，是否需要token、cookie、session等）选择爆破的方式。</p><h4 id="限制登陆频率爆破" tabindex="-1"><a class="header-anchor" href="#限制登陆频率爆破" aria-hidden="true">#</a> 限制登陆频率爆破</h4><ul><li>限制登陆频率即为在一定的时间内限制登陆次数，如同一账号，10分钟仅允许登陆10次。</li></ul><p>解决思路：对于这种方式可以采用延时爆破的方式</p><h4 id="authorization爆破" tabindex="-1"><a class="header-anchor" href="#authorization爆破" aria-hidden="true">#</a> Authorization爆破</h4><ul><li>狭义上单纯指basic base64爆破。比如tomact的密码在传输的时候，是采用base64编码的。而广义上可以泛指经过编码后的用户名和密码，</li></ul><p>解决方法：在爆破的时候经过一层编码然后再进行爆破。</p><h5 id="密文传输爆破" tabindex="-1"><a class="header-anchor" href="#密文传输爆破" aria-hidden="true">#</a> 密文传输爆破</h5><ul><li>密码从客户端到服务器端中间通过前端js代码将其加密后发送给服务器</li></ul><p>解决方法：常见的是md5或rsa，如果是js的复杂加密，则通过读取js文件的加密逻辑进行复现加密过程最后通过自定义python进行爆破，或利用pyexecjs包来帮助执行js文件复现加密的方法。</p><h4 id="session固定攻击-未授权" tabindex="-1"><a class="header-anchor" href="#session固定攻击-未授权" aria-hidden="true">#</a> Session固定攻击（未授权）</h4><ul><li><p>会话固定攻击就是利用服务器的Session不会改变的机制，利用他人的认证和授权（Session），然后冒充他人。</p></li><li><p>原理：在登陆的时候，URL带有一个session，登陆成功后会将登陆成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关人员诱导其登陆，在别人登陆成功后相当于获取了其身份信息。</p></li><li><p>漏洞点：在GET方法请求登陆的时候带有session值</p></li></ul><p>修复：</p><ol><li>避免在URL中带入session信息</li><li>检查POST请求中是否也有固定session（可利用性比较低）</li></ol><h4 id="cookie欺骗漏洞" tabindex="-1"><a class="header-anchor" href="#cookie欺骗漏洞" aria-hidden="true">#</a> Cookie欺骗漏洞</h4><ul><li>通过伪造的cookie信息能够伪造其他用户进行登陆</li><li>原理：开发者为了方便，将身份信息、登录信息名文或者只是简单编码、哈希之后存储在cookie中，服务器通过获取到cookie进行授权或者身份验证。</li><li>漏洞点：cookie中有明显或者只是简单编码、哈希的字段的时候修改该lsLogin值为1可以判定用户已经登录。</li></ul><p>修复：</p><p>cookie不应该存储可理解的身份信息和登录信息。按照规定，cookie对身份信息和登录信息只能通过存储足够长的随机字符，避免篡改。</p><h4 id="未进行登录凭证验证" tabindex="-1"><a class="header-anchor" href="#未进行登录凭证验证" aria-hidden="true">#</a> 未进行登录凭证验证</h4><ul><li>有些业务的接口，因为缺少了对用户的登录凭证的校验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。</li></ul><p>如：直接访问后台页面：在web路径上输入main.php之类的即可进入。</p><h3 id="登录验证码" tabindex="-1"><a class="header-anchor" href="#登录验证码" aria-hidden="true">#</a> 登录验证码</h3><h4 id="验证码复用" tabindex="-1"><a class="header-anchor" href="#验证码复用" aria-hidden="true">#</a> 验证码复用</h4><ul><li>验证码复用即登录失败后验证码不刷新，仍然可以使用上一次登录时的验证码。存在爆破风险的漏洞。</li></ul><p>测试方法：抓包后输入对的验证码，账号密码输入错误，反复发送查看回包。</p><h4 id="验证码可爆破" tabindex="-1"><a class="header-anchor" href="#验证码可爆破" aria-hidden="true">#</a> 验证码可爆破</h4><ul><li>验证码可爆破即验证码过于简单。比如只有四位纯数字组成还没有干扰点。</li><li>可使用pkav进行带验证码的爆破，先使用burp suite抓包，再将抓取的报文放在pkav里。</li></ul><h4 id="验证码绕过" tabindex="-1"><a class="header-anchor" href="#验证码绕过" aria-hidden="true">#</a> 验证码绕过</h4><ul><li>验证码可以通过逻辑漏洞被绕过。</li></ul><ol><li>通过burp suite修改验证码验证的返回值。</li></ol><h4 id="客户端验证" tabindex="-1"><a class="header-anchor" href="#客户端验证" aria-hidden="true">#</a> 客户端验证</h4><ul><li>通过查看源代码检查是否为前端验证码，可直接删除里面的代码来绕过。</li></ul><h4 id="无效验证" tabindex="-1"><a class="header-anchor" href="#无效验证" aria-hidden="true">#</a> 无效验证</h4><ul><li>有验证模块，但验证模块与业务功能没有关联性，此为无效验证。一般在新上线的系统中比较常见。</li></ul><h4 id="短信轰炸" tabindex="-1"><a class="header-anchor" href="#短信轰炸" aria-hidden="true">#</a> 短信轰炸</h4><ul><li>短信轰炸是手机验证码中最常见的一种漏洞类型。直接放在repeat模块进行重放。一种是完全没限制发送短信的频率，另外一种是每60秒发送一条短信。</li></ul><p>在第一种的情况下，可通过编写Python脚本来计算短信下发的时间间隔来实现短信轰炸。</p><h3 id="登录前端验证漏洞" tabindex="-1"><a class="header-anchor" href="#登录前端验证漏洞" aria-hidden="true">#</a> 登录前端验证漏洞</h3><h4 id="忘记密码-给邮箱-手机发送验证码" tabindex="-1"><a class="header-anchor" href="#忘记密码-给邮箱-手机发送验证码" aria-hidden="true">#</a> 忘记密码-给邮箱/手机发送验证码</h4><ul><li>当“忘记密码”页面输入邮箱或手机号后，网站给手机或邮箱发送验证码。用户输入验证码后服务器会将其与正确的验证码进行对比，若相同则进行下一步。网站还贴心的考虑到了万一用户手抖输错了怎么办？有两个选择： <ol><li>客户重新给手机或邮箱发送验证码，没想到用户的手抖个不停，不断输错。验证码不断地发送到邮箱或手机上（短信炸弹漏洞）。短信一毛一条，网站要破费了。</li><li>验证码再输一遍。在这种情况下，极易产生验证码爆破漏洞。如果没有多余的安全措施且验证码为纯数字，可通过burp suite进行验证码爆破。</li></ol></li></ul><h4 id="忘记密码-前端验证绕过" tabindex="-1"><a class="header-anchor" href="#忘记密码-前端验证绕过" aria-hidden="true">#</a> 忘记密码-前端验证绕过</h4><ul><li>客户端验证码是不安全的，可能导致任意账号注册、登录及重置任意用户密码等一些列问题。</li></ul><ol><li>在点击获取验证码后，按F12，在网络中检查是否存在json的数据，里面包含着验证码。</li><li>开启burpsuiite抓包，检查验证码是否加密了。可进行解密来获取验证码。</li></ol><h4 id="忘记密码-设置新密码时改他人密码" tabindex="-1"><a class="header-anchor" href="#忘记密码-设置新密码时改他人密码" aria-hidden="true">#</a> 忘记密码-设置新密码时改他人密码</h4><ul><li>修改该密码时是否可修改其他参数（如用户名、邮箱、手机）达到修改其他用户密码的目的。</li></ul><ol><li>首先在一个网站上注册一个用户，然后修改这个用户的密码，通过抓取数据包中的参数判断哪里是校验用户，通过修改关键参数，达到任意修改其他用户密码的目的。</li></ol><h4 id="忘记密码-某网站密码找回功能" tabindex="-1"><a class="header-anchor" href="#忘记密码-某网站密码找回功能" aria-hidden="true">#</a> 忘记密码-某网站密码找回功能</h4><ol><li>在用户更改密码和找回密码时，会发送一个验证码到手机，填写正确验证码后，后台会在返回的报文中通过状态码来进行正确的判断。可通过修改返回报文中的参数，使页面跳转到某以页面（还是前端验证）</li></ol><h4 id="忘记密码-链接token参数可逆" tabindex="-1"><a class="header-anchor" href="#忘记密码-链接token参数可逆" aria-hidden="true">#</a> 忘记密码-链接token参数可逆</h4><ul><li><p>通过邮箱找回密码时，邮箱中将出现一个含有token的重置url，改token即为重置凭证。</p></li><li><p>从经验来看，开发人员习惯以时间戳、递增序号、关键字段（如邮箱地址）等三类信息之一作为因子，采用某种加密算法或编码生成token，攻击者可以基于能收集到的关键字段，用常见加密算法计算一遍，以判断是否可以预测出token。</p></li></ul><h4 id="忘记密码-服务端验证逻辑缺陷" tabindex="-1"><a class="header-anchor" href="#忘记密码-服务端验证逻辑缺陷" aria-hidden="true">#</a> 忘记密码-服务端验证逻辑缺陷</h4><ul><li>在登陆状态下修改自己的密码时，通过修改截获数据包，将部分参数替换，从而修改他人的密码，然后进行登陆他人的账号。</li></ul><h4 id="忘记密码-参数带用户名等多阶段验证" tabindex="-1"><a class="header-anchor" href="#忘记密码-参数带用户名等多阶段验证" aria-hidden="true">#</a> 忘记密码-参数带用户名等多阶段验证</h4><ul><li><p>密码找回流程一般包括获取短信验证码、校验短信验证码是否有效、设置新密码等三个步骤。</p></li><li><p>在第二步，校验短信验证码是否有效的结果应保存在服务端，某些网站未在服务端保存而是错误地将结果状态值下发给客户端，后续又依靠前端js判断是否可以进入第三步。</p></li><li><p>那么可更改应答包中地状态值，可重置其他用户的密码。</p></li></ul><h4 id="重置后的默认密码" tabindex="-1"><a class="header-anchor" href="#重置后的默认密码" aria-hidden="true">#</a> 重置后的默认密码</h4><ul><li>在一些大型公司或者学校的网站上，会有介绍用户注册的指导手册，里面会介绍用户的用户名和默认密码。</li><li>这时可先用默认密码尝试爆破密码，或者寻找重置密码的选项，重置密码后用默认口令登陆。</li><li>因为可能会未授权就可修改网站用户的密码</li></ul><h3 id="任意账号密码" tabindex="-1"><a class="header-anchor" href="#任意账号密码" aria-hidden="true">#</a> 任意账号密码</h3><h4 id="未验证邮箱-手机号" tabindex="-1"><a class="header-anchor" href="#未验证邮箱-手机号" aria-hidden="true">#</a> 未验证邮箱/手机号</h4><ul><li>很多网站在注册的时候没有审核邮箱/手机号是否有效，所以利用该缺陷任意注册账号</li></ul><h4 id="批量注册" tabindex="-1"><a class="header-anchor" href="#批量注册" aria-hidden="true">#</a> 批量注册</h4><ul><li>脚本批量注册可造成服务器dos攻击，影响网站的正常使用。通常是由于上边无验证码或者验证码不安全导致的。</li></ul><h4 id="个人信息伪造" tabindex="-1"><a class="header-anchor" href="#个人信息伪造" aria-hidden="true">#</a> 个人信息伪造</h4><ul><li>若出现身份证注册，则抓包任意构造绕过身份证与真实姓名任意填写。</li></ul><h4 id="前端验证审核绕过" tabindex="-1"><a class="header-anchor" href="#前端验证审核绕过" aria-hidden="true">#</a> 前端验证审核绕过</h4><ul><li>任意填写注册信息，服务器端对注册信息进行审核，例如是否存在恶意标签等恶意信息但是通过返回状态值给前端判断，一旦篡改该值就可能绕过。</li></ul><p>第一步，使用正常账号修改密码，获取验证码通过时服务器返回数据，保存该信息</p><p>第二步，使用burpsuite或fiddle，之后点击确定，服务器会返回验证码错误之类的信息，</p><p>使用正确的信息例如{&quot;MessageHeader&quot;:{&quot;MessageID&quot;:&quot;RSP036&quot;,&quot;Description&quot;:&quot;成功！&quot;}}进行替换 后再执行，注册成功。</p><h4 id="邮箱-手机号注册激活验证绕过" tabindex="-1"><a class="header-anchor" href="#邮箱-手机号注册激活验证绕过" aria-hidden="true">#</a> 邮箱/手机号注册激活验证绕过</h4><ul><li>为防止恶意用户任意注册账户，大多数网站会在用户注册中输入邮箱/手机号后对其真实性进行验证</li><li>但是有时候返回的验证信息会直接隐藏在返回包中，只是不在前端显示出来，或者是可以通过抓包改包 手机号/邮箱，伪造该信息，劫持到验证信息</li><li>以某验证信息返回为例，该漏洞是在发送验证信息时会将验证信息同时发送到返回包中并将其在前端用 hidden属性隐藏其值</li><li>所以直接前端源代码查看即可</li></ul><h4 id="用户名覆盖" tabindex="-1"><a class="header-anchor" href="#用户名覆盖" aria-hidden="true">#</a> 用户名覆盖</h4><ul><li><p>渗透测试中，某些不严谨的开发人员，对于注册时，当输入用户名时不会对之前数据库中存在的用户名 进行检查，判断是否存在</p></li><li><p>登录查看时却获取到数据库中同名用户的其他用户信息，导致其他用户信息泄露，或者由于验证用户名 存在时，从前端获取到的数据与从数据库获取到的数据不同，但是往数据库中写入的时候却写了相同的 部分</p></li><li><p>而登陆时，当检测到是管理员用户名就给予管理员权限</p></li></ul><h3 id="权限类漏洞" tabindex="-1"><a class="header-anchor" href="#权限类漏洞" aria-hidden="true">#</a> 权限类漏洞</h3><h4 id="越权" tabindex="-1"><a class="header-anchor" href="#越权" aria-hidden="true">#</a> 越权</h4><ul><li>越权分为平行越权、垂直越权和交叉越权。</li><li>平行越权：权限类型不变，权限ID改变。</li><li>垂直越权：权限ID不变，权限类型改变。</li><li>交叉越权：权限ID、权限类型都变。</li></ul><img src="`+h+'"><h4 id="平行权限跨越" tabindex="-1"><a class="header-anchor" href="#平行权限跨越" aria-hidden="true">#</a> 平行权限跨越</h4><ul><li>水平越权是指攻击者尝试访问与他拥有相同权限的用户的资源。</li><li>比如：某系统上有个人资料的功能，A账号和B账号都可以访问这个功能，A账号的个人信息和B账号的个人信息不同。</li><li>可以理解为A账号和B账号个人资料这个功能上具备水平权限的划分。</li><li>此时A账号通过攻击手段访问了B账号的个人资料，这就是水平越权。</li><li>系统中所有具备水平权限划分的功能，都存在水平越权的风险。</li></ul><h4 id="垂直权限跨越" tabindex="-1"><a class="header-anchor" href="#垂直权限跨越" aria-hidden="true">#</a> 垂直权限跨越</h4><ul><li>垂直越权是指一个低级别权限用户通过攻击手段访问高级别权限用户的资源。</li><li>比如：某个系统分为普通用户和管理员用户。管理员有系统管理的功能，而普通用户没有。</li><li>那我们就可以理解管理功能具备垂直权限划分。</li><li>如果普通用户通过某种攻击手段访问到管理功能，那我们就称之为垂直越权。</li></ul><h3 id="其他漏洞" tabindex="-1"><a class="header-anchor" href="#其他漏洞" aria-hidden="true">#</a> 其他漏洞</h3><h4 id="数据包重放漏洞" tabindex="-1"><a class="header-anchor" href="#数据包重放漏洞" aria-hidden="true">#</a> 数据包重放漏洞</h4><ul><li>后台未进行相关操作，导致数据包重放漏洞点。如：在短信验证码、邮件校验、重复提交订单等。</li><li>通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等。</li></ul><p>修复思路（针对短信、邮件）：</p><ol><li>构造一个Hashmap&lt;String, short&gt;，存放邮箱或电话号码及对应次数。</li><li>设置邮箱或电话号码发送次数阈值。</li><li>通过计算两次发送的时间间隔，间隔果断则不继续发送</li></ol><p>通用修复方案：</p><ol><li>建立token机制或验证码机制，一次有效</li></ol><h4 id="条件竞争漏洞" tabindex="-1"><a class="header-anchor" href="#条件竞争漏洞" aria-hidden="true">#</a> 条件竞争漏洞</h4><ul><li>条件竞争是指一个系统的运行结果依赖于不受控制事件的先后顺序。</li><li>当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现bug。</li><li>通俗的讲，条件竞争涉及到的就是操作系统中所提到的进程或者线程同步的问题，当一个程序的运行结果依赖于线程的顺序，处理不当就会发生条件竞争。</li></ul><p>如：upload靶场的第18关</p><p>修复思路：</p><ol><li>限制同一时间内只允许单一线程访问</li></ol><h4 id="订单金额任意修改" tabindex="-1"><a class="header-anchor" href="#订单金额任意修改" aria-hidden="true">#</a> 订单金额任意修改</h4><ul><li>很多中小型的购物网站都存在订单金额任意修改的漏洞，在提交订单的时候抓取数据包或者直接修改前端的代码，然后对订单的金额任意修改。</li></ul><p>经常见到的参数大多为：rmb、value、amount、cash、fee、money</p><p>关于支付的逻辑漏洞这一块还有很多种思路，比如相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数，无线叠加优惠券等等。</p><h4 id="接口无限制枚举" tabindex="-1"><a class="header-anchor" href="#接口无限制枚举" aria-hidden="true">#</a> 接口无限制枚举</h4><ul><li>有些关键性的接口因为没有做验证或者其他预防机制，容易遭到爆破攻击。常见账号爆破、密码爆破、验证码爆破。</li></ul><p>如：某公司的优惠券枚举、某电商会员卡卡号枚举、某超市注册用户信息枚举。</p><h4 id="支付漏洞" tabindex="-1"><a class="header-anchor" href="#支付漏洞" aria-hidden="true">#</a> 支付漏洞</h4><ul><li>支付漏洞是<strong>高风险漏洞</strong>也是属于逻辑漏洞。通常是通过篡改价格、数量、状态、接口、用户名传参，从而造成小钱买大物。甚至可能造成0元购等。</li><li>凡是涉及购买、资金等方面的功能就可能存在支付漏洞</li></ul><p>商户网站接入支付结果，有两种方式，一种是通过浏览器进行跳转通知，另一种是服务器端异步通知。</p><p><strong>浏览器跳转通知</strong>：</p><img src="'+r+'" style="zoom:80%;"><ul><li>基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全性。（这种方式数据经过了客户端的浏览器，极大可能会被恶意的攻击者篡改）</li></ul><p><strong>服务器异步通知</strong></p><img src="'+d+'" style="zoom:80%;"><ul><li><p>当支付成功以后，支付公司服务器直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。购物平台接收异部参数的URL对应的程序中，对返回的支付结果进行签名验证成功后，进行支付逻辑处理（验证金额、订单信息，支付时间……）</p><p>大多数都使用服务器端异步通知</p></li></ul><h4 id="越权支付" tabindex="-1"><a class="header-anchor" href="#越权支付" aria-hidden="true">#</a> 越权支付</h4><ul><li>通过修改一些特殊传参（如：id、username、openid）来达到用他人的资金来购买自己的商品。</li></ul><p>如：小程序越权积分兑换</p><h4 id="无限制试用" tabindex="-1"><a class="header-anchor" href="#无限制试用" aria-hidden="true">#</a> 无限制试用</h4><ul><li>通过修改特殊传参（如id、pay，test）来达到无限制试用。</li></ul><h4 id="支付漏洞总结" tabindex="-1"><a class="header-anchor" href="#支付漏洞总结" aria-hidden="true">#</a> 支付漏洞总结</h4><ol><li>找到关键的数据包 可能一个支付操作有三四个数据包，我们要对数据包进行挑选。</li><li>分析数据包 支付数据包中会含有很多敏感信息（账号、金额、余额、优惠），要尝试对数据包中各个参数进行分析。</li><li>不按照套路出牌 多去想想开发者没有想到的地方</li><li>pc端尝试，wap端、app也试试</li></ol><h5 id="防御方法" tabindex="-1"><a class="header-anchor" href="#防御方法" aria-hidden="true">#</a> 防御方法</h5><ol><li>在后端检查订单的每一个值，包括支付状态</li><li>校验价格、数量参数。比如产品数量只能为正整数，并限制最大购买数量</li><li>与第三方支付平台检查，实际支付的金额是否与订单金额一致</li><li>如果用户退款，要使用原路，原订单 退回，比如：退押金，按用户原支付订单原路退回。</li><li>md5加密、解密，数字签名及验证，这个可以有效避免数据篡改，重放攻击等各种问题。</li><li>金额超过指定值，进行人工审核等。</li></ol><h3 id="src中逻辑漏洞检查总结" tabindex="-1"><a class="header-anchor" href="#src中逻辑漏洞检查总结" aria-hidden="true">#</a> SRC中逻辑漏洞检查总结</h3><h4 id="注册" tabindex="-1"><a class="header-anchor" href="#注册" aria-hidden="true">#</a> 注册</h4><ul><li>短信轰炸</li><li>验证码安全问题</li><li>密码爆破</li><li>邮箱轰炸</li><li>用户任意注册、批量注册</li><li>用户名枚举</li><li>XSS（有框的地方就可以尝试插XSS）</li></ul><h4 id="登陆" tabindex="-1"><a class="header-anchor" href="#登陆" aria-hidden="true">#</a> 登陆</h4><ul><li>短信轰炸、验证码安全问题、密码爆破、邮箱轰炸</li><li>SQL注入</li><li>撞库</li><li>抓包把password字段修改为空值发送</li><li>认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号</li><li>Cookie仿冒</li><li>修改返回包的相关数据，可能会登陆到其他的用户</li></ul><h4 id="找回密码" tabindex="-1"><a class="header-anchor" href="#找回密码" aria-hidden="true">#</a> 找回密码</h4><ul><li>短信邮箱轰炸、短信邮箱劫持</li><li>重置任意用户账户密码、验证码手机用户未统一验证</li><li>直接跳过验证步骤</li></ul><h4 id="支付" tabindex="-1"><a class="header-anchor" href="#支付" aria-hidden="true">#</a> 支付</h4><ul><li>购买支付、充值（要利用抓包去仔细查看每一个可用的参数）</li><li>交易金额、数量修改、更换支付模块（比如更换支付的模块金额）</li><li>交易信息订单编码/导致信息泄露</li><li>整数溢出，int最大值为2147483647，超过最大值</li><li>修改充值账户</li><li>支付绕过</li><li>抽奖活动</li><li>刷奖品、积分 • 并发 • 优惠卷、代金卷</li><li>并发逻辑漏洞（burp批量获取优惠券）</li><li>修改优惠券金额、数量</li><li>订单信息</li><li>订单信息遍历、泄露</li><li>订单信息泄露导致用户信息泄露</li><li>删出他人订单</li></ul><h4 id="支付逻辑漏洞" tabindex="-1"><a class="header-anchor" href="#支付逻辑漏洞" aria-hidden="true">#</a> 支付逻辑漏洞</h4><ul><li>金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包</li><li>确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。 • 请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。</li><li>请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。</li><li>订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后 支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。</li><li>用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务 流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自 己的东西</li></ul><h4 id="会员系统" tabindex="-1"><a class="header-anchor" href="#会员系统" aria-hidden="true">#</a> 会员系统</h4><ul><li>改个人信息上传文件，上传带弹窗的html</li><li>如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测</li><li>图片上传也可能遇到imagereagick命令执行，上传恶意图片</li><li>视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf</li><li>用户横向越权访问、遍历、导致用户信息泄露</li><li>SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS</li></ul><h4 id="传输过程、评论" tabindex="-1"><a class="header-anchor" href="#传输过程、评论" aria-hidden="true">#</a> 传输过程、评论</h4><ul><li><p>明文传输账户密码</p></li><li><p>修改信息处无session/token导致csrf</p></li><li><p>POST/COOKIE注入</p></li><li><p>POST注入</p></li><li><p>存储型XSS</p></li><li><p>无session/token导致CSRF</p></li></ul><h4 id="验证码问题、短信轰炸" tabindex="-1"><a class="header-anchor" href="#验证码问题、短信轰炸" aria-hidden="true">#</a> 验证码问题、短信轰炸</h4><ul><li><p>万能验证码</p></li><li><p>返回包中存在验证码</p></li><li><p>删除验证码或者cookie中的值可以爆破账号密码</p></li><li><p>一直重放</p></li><li><p>删除修改cookie，重放数据包</p></li><li><p>遍历参数发送数据包</p></li><li><p>手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包</p></li><li><p>请求参数修改大小写，或者添加请求参数比如&amp;id=1</p></li><li><p>一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口</p></li><li><p>如果对手机号一天的次数进行了限制，还可以再发一次短信，DOintercept之后修改为成功回显</p></li></ul><h4 id="水平越权、数据泄露、任意用户密码重置" tabindex="-1"><a class="header-anchor" href="#水平越权、数据泄露、任意用户密码重置" aria-hidden="true">#</a> 水平越权、数据泄露、任意用户密码重置</h4><ul><li>主要登陆后还是修改参数，找多个接口不断测试</li><li>关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获 取数据检测</li><li>多个账号，主要分析请求参数</li><li>再找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回删除修改cookie，重放数据包</li><li>目前大部分都是在修改密码处参数修改 • 有些是前端验证</li></ul><h4 id="登陆绕过、水平越权、垂直越权" tabindex="-1"><a class="header-anchor" href="#登陆绕过、水平越权、垂直越权" aria-hidden="true">#</a> 登陆绕过、水平越权、垂直越权</h4><ul><li>部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false 改成true，就可以登录任意用户账号</li><li>遍历ID-在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单 号等等）</li><li>ID替换如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来 获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限 进行了验证，如果没有，也会存在越权问题</li><li>观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改</li></ul>',159),t=[s];function u(o,c){return a(),l("div",null,t)}const b=i(n,[["render",u],["__file","逻辑漏洞.html.vue"]]);export{b as default};
